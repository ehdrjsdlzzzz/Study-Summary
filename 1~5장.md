## 테스트 주도 개발 - 켄트백



### 1장. 다중 통화를 지원하는 Money 객체

---

**의존성과 중복**

테스트와 코드 간의 문제는 중복이 아니다. 의존성이다. 

의존성이 문제 그 자체라면 중복은 문제의 징후다. 하지만 중복 제거만으로도 문제 자체, 즉 의존성을 해결할 수 있다. 



TDD의 핵심은 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.



### 2장. 타락한 객체

---

**초록색(테스트 성공)**을 빨리 보기 위한 전략.

1. 가짜로 구현하기 - 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
2. 명박한 구현 사용하기
3. 삼각측량



지금까지 배운 것.

- 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환했다. 
- 스텁(가짜) 구현으로 빠르게 컴파일을 통과하도록 만들었다. 
- 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다. 



### 3장. 모두를 위한 평등

---

객체를 값처럼 사용하는 것을 **값 객체 패턴(Value object pattern)**이라 한다. 값 객체에 대해 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것. 

**동치성**

⁉️*여기서 말하는 삼각측량이란?*



지금까지 배운 것.

- 우리의 디자인 패턴이 하나의 또 다른 오퍼레이션을 암시한다는 것을 알아챘다.
- 해당 오퍼레이션을 테스트했다. 
- 해당 오퍼레이션을 간단히 구현했다. 
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다. 
- 두 경우를 모두 수용할 수 있도록 리팩토링했다.



### 4장. 프라이버시

---

동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증하는데 실패한다면, 곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는 데 실패하게 된다.

(*같다는 걸 검증하는 로직이 틀렸다면? 을 말하는 것인가?*)



지금까지 배운 것.

- 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다. 
- 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.⁉️
- 위험 요소가 있음에도 계속 진행했다. 
- 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.



### 5장. 솔직히 말하자면

---

테스트 주기

1. 테스트 작성
2. 컴파일되게 하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복 제거 

처음 네 단계는 빠르게 진행해야 한다. 어떤 죄(중복)든 저지를 수 있다.



지금까지 배운 것.

- 큰 테스트를 공략할 수 없다. 그래서 진전을 나타낼 수 있는지 자그마한 테스트를 만들었다.
- 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다. 
- 설상가상으로 모델 코드까지 도매금으로 복사하고 수정해서 테스트를 통과했다. 
- 중복이 사라지기 전에는 집에 가지 않겠다고 약속했다.



### 6장. 돌아온 '모두를 위한 평등'

---

5장에서 새로운 테스트 케이스를 추가했다. 하지만 테스트를 빨리 통과하기 위해 몇 톤이나 되는 코드를 복사해서 붙이는 엄청난 죄를 저질렀다. 

`Dollar`와 `Franc` 클래스는 `Money` 클래스를 상속받도록 하여 중복 코드를 최소화했다. 

충분한 테스트가 없다면 지원 테스트가 갖춰지지 않는 리팩토링을 만날 수 밖에 없다. 

있으면 좋을 것 같은 테스트를 작성하라. 그렇게 하지 않으면 결국에는 리팩토링하다가 뭔가 깨뜨릴 것이다. 



지금까지 배운 것.

- 공통된 코드를 첫 번째 클래스에서 상위 클래스로 단계적으로 옮겼다. 
- 두 번째 클래스(`Franc`)도 `Money`의 하위 클래스로 만들었다. 
- 불필요한 구현을 제거하기 전에 두 `equal` 구현을 일치시켰다. 



지금까지의 코드 

```swift
class Money {
  fileprivate var amount: Int

  init(_ amount: Int) {
    self.amount = amount
  }
}

extension Money: Equatable {
  static func == (lhs: Money, rhs: Money) -> Bool {
    return lhs.amount == rhs.amount
  }
}

class Dollar: Money {
  func times(_ multiplier: Int) -> Dollar {
    return Dollar(amount * multiplier)
  }

  func equals(_ dollar: Dollar) -> Bool {
    return amount == dollar.amount
  }
}

class Franc: Money {
  func times(_ multiplier: Int) -> Franc {
    return Franc(amount * multiplier)
  }

  func equals(_ dollar: Franc) -> Bool {
    return amount == dollar.amount
  }
}

class TDD_PracticeTests: XCTestCase {

  func testMultiplication() {
    let five: Dollar = Dollar(5)
    XCTAssertEqual(Dollar(10), five.times(2))
    XCTAssertEqual(Dollar(15), five.times(3))
  }

  func testEquality() {
    XCTAssertTrue(Dollar(5).equals(Dollar(5)))
    XCTAssertFalse(Dollar(5).equals(Dollar(6)))
  }

  func testFrancMultiplication() {
    let five: Franc = Franc(5)
    XCTAssertEqual(Franc(10), five.times(2))
    XCTAssertEqual(Franc(15), five.times(3))
  }
}
```

